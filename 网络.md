# 网络

### 状态码

> 状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误

|      | 类别                            | 类别                       |
| ---- | ------------------------------- | -------------------------- |
| 1xx  | Informational(信息性状态码)     | 接受的请求正在处理         |
| 2xx  | Success(成功状态码)             | 请求正常处理完毕           |
| 3xx  | Redirection(重定向状态码)       | 需要进行附加操作一完成请求 |
| 4xx  | Client Error (客户端错误状态码) | 服务器无法处理请求         |
| 5xx  | Server Error(服务器错误状态码)  | 服务器处理请求出错         |

#### 2xx 成功

> 2XX 的响应结果表明请求被正常处理了

##### 	200正常处理

> ​	响应交过表明请求被正常处理了

##### 	204无内容

> ​	服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。

#### 3xx 重定向

> 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求

##### 	301永久性移动

> ​	该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。

##### 	302临时重定向

> ​	该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。

##### 303另一个url

> ​	该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源

##### 304未修改

> ​	自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。

#### 4XX 客户端

> ​	该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

##### 401 未验证

> ​	该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用 户认证失败。
>
> ​	当浏览器初次接收到 401 响应，会弹出认证用的对话窗

##### 403不允许访问 拒绝

> ​	该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。
>
> ​	未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因

##### 404 没有请求得资源

> ​	该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使

#### 5xx服务器错误

##### 500 内部服务出错

> 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。

##### 503服务不可用

> 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter 首部字段再返回给客户

### http头部信息

#### 请求头

> 请求头用于说明是谁或什么在发送请求、请求源于何处，或者客户端的喜好及能力。服务器可以根据请求头部给出的客户端信息，试着为客户端提供更好的响应。

> - Accept:浏览器能够处理的内容类型
> - Accept-Charset:浏览器能够显示的字符集
> - Accept-Encoding：浏览器能够处理的压缩编码
> - Accept-Language：浏览器当前设置的语言
> - Connection：浏览器与服务器之间连接的类型
> - Cookie：当前页面设置的任何Cookie
> - Host：发出请求的页面所在的域
> - Referer：发出请求的页面的URL
> - User-Agent：浏览器的用户代理字符串

#### 响应头

> 响应头向客户端提供一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些头部有助于客户端处理响应，并在将来发起更好的请求。

> - Date：表示消息发送的时间，时间的描述格式由rfc822定义
> - server:服务器名字。
> - Connection：浏览器与服务器之间连接的类型
> - content-type:表示后面的文档属于什么MIME类型
> - Cache-Control：控制HTTP缓存

[http请求头]: https://blog.csdn.net/wangzhen_csdn/article/details/80776991

#### 实体头

> 实体头部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体头部可以告知接收者它在对什么进行处理。请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。

> **Allow** ：服务器支持哪些请求方法（如GET、POST等）。
>
> Location 表示客户应当到哪里去提取文档，用于将接收端定位到资源的位置（URL）上。
>
> Content-Base　解析主体中的相对URL时使用的基础URL。
>
> Content-Encoding　　WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip
>
> Content-Language　　WEB 服务器告诉浏览器理解主体时最适宜使用的自然语言。
>
> Content-Length　　WEB服务器告诉浏览器自己响应的对象的长度或尺寸，例如：Content-Length: 26012
>
> Content-Location　　资源实际所处的位置。
>
> Content-MD5　　主体的MD5校验和。
>
> Content-Range　　实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式： Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth。例如，传送头500个字节次字段的形式：Content-Range:bytes0- 499/1234如果一个http消息包含此节（例如，对范围请求的响应或对一系列范围的重叠请求），Content-Range表示传送的范围，Content-Length表示实际传送的字节数。
>
> **Content-Type**　　WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml
>
> Etag　　就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。
>
> Expires　　WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT
>
> Last-Modified　　WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT

