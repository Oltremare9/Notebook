# 多线程

### <u>线程同步的方式</u>

#### object的wait notify 

> 需要阻塞
>
> JVM会为一个使用内部锁（synchronized）的对象维护两个集合，**Entry Set**和**Wait Set**
>
> 对于Entry Set：如果线程A已经持有了对象锁，此时如果有其他线程也想获得该对象锁的话，它只能进入Entry Set，并且处于线程的BLOCKED状态。
>
> 对于Wait Set：如果线程A调用了wait()方法，那么线程A会释放该对象的锁，进入到Wait Set，并且处于线程的WAITING状态。
>
> 某个线程B想要获得对象锁，一般情况下有两个先决条件，一是对象锁已经被释放了（如曾经持有锁的前任线程A执行完了synchronized代码块或者调用了wait()方法等等），二是线程B已处于RUNNABLE状态。
>
> 对于Entry Set中的线程，当对象锁被释放的时候，JVM会唤醒处于Entry Set中的某一个线程，这个线程的状态就从BLOCKED转变为RUNNABLE。
>
> 对于Wait Set中的线程，当对象的notify()方法被调用时，JVM会唤醒处于Wait Set中的某一个线程，这个线程的状态就从WAITING转变为RUNNABLE；或者当notifyAll()方法被调用时，Wait Set中的全部线程会转变为RUNNABLE状态。所有Wait Set中被唤醒的线程会被转移到Entry Set中。

```java
	static class A extends Thread {
        public void run() {
            while (true) {
                synchronized (lockA){
                    System.out.print("A");
                    lockA.notify();
                    try {
                        lockA.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
```

> 此处交替输出AB所以使用一个锁来限制



#### 简单的显式lock的方式 和信号量方式类似

```java
	static Lock lock = new ReentrantLock();
    static Integer i = new Integer(3);

    static class A extends Thread {
        public void run() {
            while (true) {
                lock.lock();
                while (i % 3 == 0) {
                    System.out.print("a");
                    i++;
                }
                lock.unlock();
            }
        }
    }
```



#### condition的await和signal

```java
	static Lock lock = new ReentrantLock();
    static Condition a=lock.newCondition();
    static Condition b=lock.newCondition();
    static Condition c=lock.newCondition();
```

> 通过lock来创建不同的condition 每个condition类似于对应某个输出
>
> await对应wait  signal对应notify signalAll对应notifyAll

```java
	static class A extends Thread {
        public void run() {
            while (true) {
                lock.lock();
                while (i % 3 != 0) {
                    try {
                        a.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                i++;
                System.out.print("a");
                b.signal();
                lock.unlock();
            }
        }
    }
```

##### condition原理 

*（AQS维护blocked condition维护一个waiting的FIFO队列）*

> 我们知道Lock的本质是AQS，AQS自己维护的队列是当前等待资源的队列，AQS会在资源被释放后，依次唤醒队列中从前到后的所有节点，使他们对应的线程恢复执行，直到队列为空。而Condition自己也维护了一个队列，该队列的作用是维护一个等待signal信号的队列。但是，两个队列的作用不同的，事实上，每个线程也仅仅会同时存在以上两个队列中的一个，流程是这样的：
>
> \1. 线程1调用reentrantLock.lock时，尝试获取锁。如果成功，则返回，从AQS的队列中移除线程；否则阻塞，保持在AQS的等待队列中。
> \2. 线程1调用await方法被调用时，对应操作是被加入到Condition的等待队列中，等待signal信号；同时释放锁。
> \3. 锁被释放后，会唤醒AQS队列中的头结点，所以线程2会获取到锁。
> \4. 线程2调用signal方法，这个时候Condition的等待队列中只有线程1一个节点，于是它被取出来，并被加入到AQS的等待队列中。注意，这个时候，线程1 并没有被唤醒，只是被加入AQS等待队列。
> \5. signal方法执行完毕，线程2调用unLock()方法，释放锁。这个时候因为AQS中只有线程1，于是，线程1被唤醒，线程1恢复执行。
> 所以：
> 发送signal信号只是将Condition队列中的线程加到AQS的等待队列中。只有到发送signal信号的线程调用reentrantLock.unlock()释放锁后，这些线程才会被唤醒。
>
> 可以看到，整个协作过程是靠结点在AQS的等待队列和Condition的等待队列中来回移动实现的，Condition作为一个条件类，很好的自己维护了一个等待信号的队列，并在适时的时候将结点加入到AQS的等待队列中来实现的唤醒操作。

#### Semaphore信号量

> 类似于同步信号量的形式，更加方便操作

```java
	static Semaphore a=new Semaphore(1);
    static Semaphore b=new Semaphore(0);
    static class A extends Thread{
        public void run(){
            while(true) {
                try {
                    a.acquire();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.print("a");
                b.release();
            }
        }
    }
    static class B extends Thread{
        public void run(){
            while(true) {

                try {
                    sleep(100);
                    b.acquire();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("b");
                a.release();
            }
        }
    }
    static class C extends Thread{
        public void run(){
            while(true) {
                try {
                    sleep(100);
                    b.acquire();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("c");
                a.release();
            }
        }
    }
```

> 交替输出AB 或 AC





### <u>ThreadLocal软引用</u>

> **强引用**：只有当没有引用指向该对象才会进行gc
>
> **软引用**：只有在堆空间满后才会在gc时回收
>
> **软引用**：被gc时会就会被回收u
>
> ThreadLocal作为线程私有属性 thread中会有一个强引用指向threadlocal对象
>
> threadlocal的本质是thread本身维护一个map，其中键为弱引用的threadlocak 值为object
>
> 之所以使用软引用是防止在thread对象的强引用消除后，仍有key指针指向threadlocal导致空间无法回收
>
> 但是即使使用了弱引用后，仍有可能需要remove来消除这条记录



### <u>线程池的概念</u>



### 如何关闭一个线程池

> shutdownnow
>
> shutdown

### <u>如何确定一个线程池的参数 设置是合理的</u>

