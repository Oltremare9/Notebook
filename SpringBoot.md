## SpringBoot

### <u>SpringBoot在Controller中的常用注解</u>

> #### @RestController
>
> ​	等于@Controller + @ReponseBody
>
> ​	使用@RestController返回的是return里面的字符串 json



> @GetMapping
>
> ​	是@RequestMapping(method=RequestMethod.GET)缩写
>
> @PostMapping	对应post请求
>
> @PutMapping		对应put请求
>
> @DeleteMapping 对应delete请求



### <u>动态代理的两种实现区别</u>

#### 	原生JDK

> ​	通过java的反射机制
>
> ​	生成类的过程中比较高效
>
> ​	目标类必须基于统一的接口
>
> ​	就是通过让target类和代理类实现同一接口，代理类持有target对象，来达到方法拦截的作用，这样通过接口的方式有两个弊端，一个是必须保证target类有接口，第二个是如果想要对target类的方法进行代理拦截，那么就要保证这些方法都要在接口中声明，实现上略微有点限制。

#### 	CGLIB

> ​	通过asm来实现
>
> ​	生成类后的相关执行过程比较高效
>
> ​	它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：
>
> cglib有两种可选方式，继承和引用。第一种是基于继承实现的动态代理，所以可以直接通过super调用target方法，但是这种方式在spring中是不支持的，因为这样的话，这个target对象就不能被spring所管理，所以cglib还是才用类似jdk的方式，通过持有target对象来达到拦截方法的效果。

### <u>Spring和SpringMVC的理解</u>

#### 	MVC概述

> ​	在早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 **Model1：**
>
> ![img](https://upload-images.jianshu.io/upload_images/7896890-7b3f9cd59394b017.png?imageMogr2/auto-orient/strip|imageView2/2/w/963/format/webp)**出现的弊端：**
>
> JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起
>
> 要求开发者不仅要掌握 Java ，还要有高超的前端水平
>
> 前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试
>
> 代码难以复用
>
> 
>
> 正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型**（Model2）**就像下图这样：
>
> ![img](https://upload-images.jianshu.io/upload_images/7896890-403a273b08fec826.png?imageMogr2/auto-orient/strip|imageView2/2/w/985/format/webp)
>
> 首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。
>
> **M 代表 模型（Model）**
>  模型是什么呢？ 模型就是数据，就是 dao,bean
>
> **V 代表 视图（View）**
>  视图是什么呢？ 就是网页, JSP，用来展示模型中的数据
>
> **C 代表 控制器（controller)**
>  控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。

#### 	SpringMVC

> ![img](https://upload-images.jianshu.io/upload_images/7896890-a25782fb05f315de.png?imageMogr2/auto-orient/strip|imageView2/2/w/1176/format/webp)
>
> **传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。** 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。
>
> **特点：**
> 结构松散，几乎可以在 Spring MVC 中使用各类视图
> 松耦合，各个模块分离
> 与 Spring 无缝集成

#### 	springMVC的请求过程

> ![img](https://upload-images.jianshu.io/upload_images/7896890-65ef874ad7da59a2.png?imageMogr2/auto-orient/strip|imageView2/2/w/784/format/webp)
>
> 第一站到达的就是 **DispatcherServlet**，DispatcherServlet 会拦截所有的请求，并且将这些请求发送给 Spring MVC 控制器。
>
> **DispatcherServlet 的任务就是拦截请求发送给 Spring MVC 控制器。**
>
> 第二站**处理器映射（HandlerMapping）** DispatcherServlet 会查询一个或多个处理器映射来确定请求的下一站在哪里，处理器映射会**根据请求所携带的 URL 信息来进行决策**
>
> 第三站**控制器**一旦选择了合适的控制器， DispatcherServlet 会将请求发送给选中的控制器，到了控制器，请求会卸下其负载（用户提交的请求）等待控制器处理完这些信息
>
> 第四站 **返回 DispatcherServlet**当控制器在完成逻辑处理后，通常会产生一些信息，这些信息就是需要返回给用户并在浏览器上显示的信息，它们被称为**模型（Model）**仅仅返回原始的信息时不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML，所以，信息需要发送给一个**视图（view）**，通常会是 JSP。控制器所做的最后一件事就是将模型数据打包，并且表示出用于渲染输出的视图名**（逻辑视图名）。它接下来会将请求连同模型和视图名发送回 DispatcherServlet。**
>
> 第五站**控制器** 这样就不会和特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的 JSP。（实际上，它甚至不能确定视图就是 JSP）相反，**它传递的仅仅是一个逻辑名称，这个名称将会用来查找产生结果的真正视图。**DispatcherServlet 将会使用视图解析器（view resolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 JSP
>
> 第六站**视图** 既然 DispatcherServlet 已经知道由哪个视图渲染结果了，那请求的任务基本上也就完成了。它的最后一站是视图的实现，在这里它交付模型数据，请求的任务也就完成了。视图使用模型数据渲染出结果，这个输出结果会通过响应对象传递给客户端。



### <u>@Transactional的理解</u>

> @Transactional不仅可以注解在方法上，也可以注解在类上。
>
> 当注解在类上的时候意味着此类的所有public方法都是开启事务的。
>
> 如果类级别和方法级别同时使用了@Transactional注解，则使用在类级别的注解会重载方法级别的注解



### <u>隔离级别</u>

> DEFAULT ：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是： READ_COMMITTED 。
> READ_UNCOMMITTED ：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。
> READ_COMMITTED ：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。
> REPEATABLE_READ ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。
> SERIALIZABLE ：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

> 指定方法：通过使用 isolation 属性设置，例如：
> @Transactional(isolation = Isolation.DEFAULT)

### <u>事务传播级别</u>

> **REQUIRED** ：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。**默认的spring事务传播级别**
>
> 如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。
>
> **SUPPORTS** ：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
>
> **MANDATORY** ：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。
>
> 比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。
>
> **REQUIRES_NEW** ：创建一个新的事务，如果当前存在事务，则把当前事务挂起。
>
> 举一个应用场景：现在有一个发送100个红包的操作，在发送之前，要做一些系统的初始化、验证、数据记录操作，然后发送100封红包，然后再记录发送日志，发送日志要求100%的准确，如果日志不准确，那么整个父事务逻辑需要回滚。
> 怎么处理整个业务需求呢？就是通过这个PROPAGATION_REQUIRES_NEW 级别的事务传播控制就可以完成。发送红包的子事务不会直接影响到父事务的提交和回滚。
>
> **NOT_SUPPORTED** ：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
>
> 可以帮助你将事务极可能的缩小。我们知道一个事务越大，它存在的风险也就越多。所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况。所以这个事务这个级别的传播级别就派上用场了。用当前级别的事务模板抱起来就可以了。
>
> **NEVER** ：以非事务方式运行，如果当前存在事务，则抛出异常。
>
> **NESTED** ：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED 。



### <u>什么是Restful API</u>

> 本质上是一种设计规范，应用于前后端分离的项目中，用于规范API设计

#### 	设计原则

> 客户端-服务器：通过将用户UI与数据存储分开，我们可以简化服务器组件来提高跨多个平台的用户界面的可移植性并提高可伸缩性。 它可以比表现成前后端分离的思想。
>
> 无状态：从客户端到服务器的每个请求都必须包含理解请求所需的所有信息，并且不能利用服务器上任何存储的上下文。 这表示你应该尽可能的避免使用session，由客户端自己标识会话状态。（token）
>
> 规范接口：REST接口约束定义：资源识别; 请求动作; 响应信息; 它表示通过uri标出你要操作的`资源`，通过请求动作（http method）标识要执行的操作，通过返回的状态码来表示这次请求的执行结果。
>
> 可缓存： 缓存约束要求将对请求的响应中的数据隐式或显式标记为可缓存或不可缓存。如果响应是可缓存的，则客户端缓存有权重用该响应数据以用于以后的等效请求。 它表示get请求响应头中应该表示有是否可缓存的头（Cache-Control)

#### 	请求动作

> get	查询操作
>
> post  新增动作
>
> put	更新操作
>
> patch部分更新
>
> delete删除操作

#### 	无状态

> 无状态通过将API部署到多个服务器，有助于将API扩展到数百万并发用户。任何服务器都可以处理任何请求，因为没有与会话相关的依赖。（集群）
>
> 无状态使得REST API不那么复杂 - 可以删除所有服务器端状态同步逻辑。（删除session，清理多余空间）
>
> 无状态API也很容易缓存。特定软件可以通过查看该一个请求来决定是否缓存HTTP请求的结果。从先前的请求中获得的状态可能会影响这个请求的可缓存性，这并不存在任何不确定性。它提高了应用程序的性能。
>
> 服务器永远不会忘记每个客户端身份”，因为客户端会在每个请求中发送所有必要的信息。（携带token）





### 单例模式和spring的单例有什么区别



### <u>如何优化减库存操作</u>

初始方法

```
query();
@transactional
set quantity=quantity-1
```

问题：在第一次进行查询时，如果不加事务的标记，则会导致超卖问题。如果加上了事务标记，则会影响并发

解决方案：不要进行query查询库存，直接用一次sql来处理，在一次sql中执行以下操作

```mysql
update set quantity=quantity-1
where good_id=1 and quantity>0
```

### <u>做登陆时有什么其他办法做用户的参数解析</u>

> 1用目前采用的方法。在请求发送到controller之前，用参数解析器，进行参数的解析。以用户信息实体的形式，传入controller
>
> 2threadlocal的形式来存放用户的相关信息。直接使用线程上下文的形式



### springboot 和 springmvc的区别